---
title: "Lista 3 - Tópicos em ML"
execute:
  warning: false
author:   
  - Luben M. C. Cabezas
  - Reinaldo C. Anacleto
tbl-cap-location: top
format:
  pdf:
     df-print: kable
     include-in-header:  
        - text: |
            \usepackage{amsmath}
---
Primeiramente, importando bibliotecas que serão utilizadas:

```{r}
# bibliotecas do R
library(ggplot2)
library(MASS)
library(BART)
library(purrr)
library(dplyr)
```

\section{Exercício 1}
Importando o conjunto de dados de proteinas:
```{r}
# importando os dados
protein_data <- read.csv("data/CASP.csv")
# visualizando numero de variaveis, observações e tipo de cada variavel
protein_data |> str()
```
Dividindo o conjunto em treino, calibração e teste. O conjunto de calibração será usado apenas para os métodos conformal:
```{r}
set.seed(45)
# Dividindo em treino e teste
n_train_val <- floor(0.9 * nrow(protein_data))
train_val_ind <- sample(seq_len(nrow(protein_data)), n_train_val)
train_val_data <- protein_data[train_val_ind, ]
test_data <- protein_data[-train_val_ind, ]

# dividindo em treino e calibração
n_cal<- floor(0.5 * nrow(train_val_data))
train_cal_ind <- sample(seq_len(nrow(train_val_data)), n_cal)
calib_data <- train_val_data[train_cal_ind, ]
train_data <- train_val_data[-train_cal_ind, ]

# Transformando em matrizes
# matriz de features
X_train <- train_data |> dplyr::select(-1) |> as.matrix()
X_calib <- calib_data |> dplyr::select(-1) |> as.matrix()
X_test <- test_data |> dplyr::select(-1) |> as.matrix()

# resposta
y_train <- train_data |> pull(1)
y_calib <- calib_data |> pull(1)
y_test <- test_data |> pull(1)

# matrizes para intervalos preditivos bayesiano
X_train_b <- train_val_data |> dplyr::select(-1) |> as.matrix()
y_train_b <- train_val_data |> pull(1)
n_test <- nrow(X_test)
```
\subsection{Item 1}

\subsection{Item 2}

\subsection{Item 3}

\subsection{Item 4}
Para esse exemplo, utilizaremos o conjunto de dados de treino completo. Utilizaremos o pacote BART no R, obtendo uma amostra de $1000$ da posteriori para obter as regiões preditivas para $Y$:
Agora ajustando o BART:
```{r}
#| cache: true
# Set seed for reproducibility
set.seed(686)
# Fit BART model
post <- wbart(X_train_b, y_train_b, X_test, ndpost = 1000)
```
Obtemos agora uma região preditiva simétrica e a região preditiva quantílica:
```{r}
alpha <- 0.05
# Obtendo os lower e upper bounds da regiao simetrica para o conjunto de teste
means <- post$yhat.test.mean
std_dev <- sqrt(mean(post$sigma)^2 + apply(post$yhat.test, 2, sd)^2)
lower_bound_sym <- means - 1.96 * std_dev
upper_bound_sym <- means + 1.96 * std_dev

sigmas <- post$sigma[101:1100]
# Obtendo os lower e upper bounds da região baseada nos quantis
# encontrando quantil inferior usando monte carlo
y_new <- 1:length(y_test) |>
map(function(.x){
  y_sim <- post$yhat.test[, .x]
  return(
    rnorm(length(y_sim), mean = y_sim, sd = sigmas)
  )
}) |> unlist() |> matrix(nrow = 1000)

# grid em y
lower_bound_q <- apply(y_new, 2, quantile, probs = alpha/2)
upper_bound_q <- apply(y_new, 2, quantile, probs = (1 - alpha/2)) 
```
Tendo ambas as regiões, podemos a seguir calcular a cobertura empírica nesses casos:
```{r}
cover_sym <- ((lower_bound_sym <= y_test) & 
(upper_bound_sym >= y_test)) |>
mean()

cover_q <- ((lower_bound_q <= y_test) & 
(upper_bound_q >= y_test)) |>
mean()

data.frame("Região Preditiva" = c("Simétrica", "Quantílica"),
"Cobertura empírica" = c(cover_sym, cover_q) |> round(4))
```
Percebe-se que ambas regiões são razoavelmente próximas da cobertura nominal 0.95, tendo porém uma leve sub-cobertura, principalmente a região quantílica que está um pouco mais distante do nível nominal que o intervalo simétrico. Podemos também observar pela [Figura @fig-pred-int-bayes] as regiões preditivas estimadas no conjunto de teste para 5 diferentes valores.
```{r}
#| label: fig-pred-int-bayes
#| fig-cap: "Intervalos preditivos bayesianos para as observações selecionadas. Pontos em vermelho representam o rótulo observado para cada observação enquanto pontos azuis representam a média a posteriori em cada caso."
#| fig-align: center
#| fig-pos: '!http'
#| echo: false

# valores para as regiões de predição
vals_idx <- c(2, 50, 175, 600, 1250)
true_y <- y_test[vals_idx]
pred_data <- data.frame(
  indices = c(paste0("Obs ", rep(vals_idx, 2))),
  lower_bound = c(
  lower_bound_sym[vals_idx], lower_bound_q[vals_idx]),
  upper_bound = c(upper_bound_sym[vals_idx],
  upper_bound_q[vals_idx]),
  truth_values = c(rep(true_y, 2)),
  mean_values = c(rep(means[vals_idx], 2)),
  type = c(rep(c("Simétrica", "Quantílica"), each = 5)))

# Plotting the pred_data lower and upper bound
ggplot(pred_data, aes(x = type, ymin = lower_bound, ymax = upper_bound)) +
  geom_linerange() +
  geom_point(aes(y = truth_values), colour = "red") +
  geom_point(aes(y = mean_values), colour = "blue")+
  facet_wrap(~ indices, scales = "fixed") +
  labs(
    title = "Regiões Preditivas Estimadas",
    x = "Tipo de Região",
    y = "Variável resposta"
  ) +
  theme_minimal()
```
Primeiramente visualiza-se nesses casos em particular que todos os intervalos preditivos contém o valor observado de $Y$. Percebemos também que há poucas diferenças entre os tipos de regiões, com ambas tendo tamanhos similares e razoavelmente largos. Além disso, as regiões quantílicas são visualmente apenas um pouco assimétricas em torno da média e um pouco mais curtas que as regiões simétricas. Podemos comparar adicionalmente a largura média das regiões através da seguinte tabela:
```{r}
data.frame(
  "Região Preditiva" = c("Simétrica", "Quantílica"),
  "Largura" = c(
    mean(upper_bound_sym - lower_bound_sym),
    mean(upper_bound_q - lower_bound_q)),
  "SE*2" = c(
    2*sqrt(var(upper_bound_sym - lower_bound_sym)/n_test),
    2*sqrt(var(upper_bound_q - lower_bound_q)/n_test)
  )
)
```
Concluindo que de fato, as regiões quantílica são em média um pouco menos largas que as regiões simétricas.



